diff -rupN ns-allinone-3.27/ns-3.27/examples/bbr-tests/bulk.cc ns-allinone-3.27-bbr/ns-3.27/examples/bbr-tests/bulk.cc
--- ns-allinone-3.27/ns-3.27/examples/bbr-tests/bulk.cc	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-3.27-bbr/ns-3.27/examples/bbr-tests/bulk.cc	2018-01-30 17:52:25.597435941 -0500
@@ -0,0 +1,187 @@
+//           
+// Network topology
+//
+//       n0 ------------ (n1/router) -------------- n2
+//            10.1.1.x                192.168.1.x
+//       10.1.1.1    10.1.1.2   192.16.1.1     192.168.1.2
+//
+// - Flow from n0 to n2 using BulkSendApplication.
+//
+// - Tracing of queues and packet receptions to file "*.tr" and
+//   "*.pcap" when tracing is turned on.
+// 
+// - Change of bandwidth UP partway through, then DOWN before end.
+//
+
+// System includes.
+#include <string>
+#include <fstream>
+
+// NS3 includes.
+#include "ns3/core-module.h"
+#include "ns3/point-to-point-module.h"
+#include "ns3/internet-module.h"
+#include "ns3/applications-module.h"
+#include "ns3/network-module.h"
+#include "ns3/packet-sink.h"
+#include "ns3/ipv4-global-routing-helper.h"
+
+using namespace ns3;
+
+// Constants.
+#define VZ_ENABLE_PCAP      true      // Set to "false" to disable pcap
+#define VZ_ENABLE_TRACE     true      // Set to "false" to disable trace
+#define VZ_BIG_QUEUE        2000      // Packets
+#define VZ_QUEUE_SIZE       100       // Packets
+#define VZ_START_TIME       0.0       // Seconds
+#define VZ_STOP_TIME        5.0       // Seconds
+#define VZ_S_TO_R_BW        "150Mbps" // Server to router
+#define VZ_S_TO_R_DELAY     "10ms"
+#define VZ_R_TO_C_BW        "10Mbps"  // Router to client (bttlneck)
+#define VZ_R_TO_C_DELAY     "1ms"
+#define VZ_PACKET_SIZE      1000      // Bytes.
+
+// Uncomment one of the below.
+#define VZ_TCP_PROTOCOL     "ns3::TcpBbr"
+//#define VZ_TCP_PROTOCOL     "ns3::TcpNewReno"
+
+// For logging.  Note, to display, set environment variable:
+NS_LOG_COMPONENT_DEFINE ("main");
+
+/////////////////////////////////////////////////
+int main (int argc, char *argv[]) {
+
+  /////////////////////////////////////////
+  // Setup environment
+  LogComponentEnable("PacketSink", LOG_LEVEL_INFO);
+  Config::SetDefault("ns3::TcpL4Protocol::SocketType",
+                     StringValue(VZ_TCP_PROTOCOL));
+
+  // Report parameters.
+  NS_LOG_INFO("TCP protocol: " << VZ_TCP_PROTOCOL);
+  NS_LOG_INFO("Server to Router Bwdth: " << VZ_S_TO_R_BW);
+  NS_LOG_INFO("Server to Router Delay: " << VZ_S_TO_R_DELAY);
+  NS_LOG_INFO("Router to Client Bwdth: " << VZ_R_TO_C_BW);
+  NS_LOG_INFO("Router to Client Delay: " << VZ_R_TO_C_DELAY);
+  NS_LOG_INFO("Packet size (bytes): " << VZ_PACKET_SIZE);
+  
+  // Set segment size (otherwise, default is 536).
+  Config::SetDefault("ns3::TcpSocket::SegmentSize",
+                     UintegerValue(VZ_PACKET_SIZE)); 
+
+  // Turn off delayed ack (so, acks every packet).
+  // Note, BBR' can still work without this.
+  Config::SetDefault("ns3::TcpSocket::DelAckCount", UintegerValue(0));
+   
+  /////////////////////////////////////////
+  // Create nodes.
+  NS_LOG_INFO("Creating nodes.");
+  NodeContainer nodes;  // 0=source, 1=router, 2=sink
+  nodes.Create(3);
+
+  /////////////////////////////////////////
+  // Create channels.
+  NS_LOG_INFO("Creating channels.");
+  NodeContainer n0_to_r = NodeContainer(nodes.Get(0), nodes.Get(1));
+  NodeContainer r_to_n1 = NodeContainer(nodes.Get(1), nodes.Get(2));
+
+  /////////////////////////////////////////
+  // Create links.
+  NS_LOG_INFO("Creating links.");
+
+  // Server to Router.
+  int mtu = 1500;
+  PointToPointHelper p2p;
+  p2p.SetDeviceAttribute("DataRate", StringValue (VZ_S_TO_R_BW));
+  p2p.SetChannelAttribute("Delay", StringValue (VZ_S_TO_R_DELAY));
+  p2p.SetDeviceAttribute ("Mtu", UintegerValue(mtu));
+  NetDeviceContainer devices1 = p2p.Install(n0_to_r);
+
+  // Router to Client.
+  p2p.SetDeviceAttribute("DataRate", StringValue (VZ_R_TO_C_BW));
+  p2p.SetChannelAttribute("Delay", StringValue (VZ_R_TO_C_DELAY));
+  p2p.SetDeviceAttribute ("Mtu", UintegerValue(mtu));
+  NS_LOG_INFO("Router queue size: "<< VZ_QUEUE_SIZE);
+  p2p.SetQueue("ns3::DropTailQueue",
+               "Mode", StringValue ("QUEUE_MODE_PACKETS"),
+               "MaxPackets", UintegerValue(VZ_QUEUE_SIZE));
+  NetDeviceContainer devices2 = p2p.Install(r_to_n1);
+
+  /////////////////////////////////////////
+  // Install Internet stack.
+  InternetStackHelper internet;
+  internet.Install(nodes);
+  
+  /////////////////////////////////////////
+  // Add IP addresses.
+  NS_LOG_INFO("Assigning IP Addresses.");
+  Ipv4AddressHelper ipv4;
+  ipv4.SetBase("10.1.1.0", "255.255.255.0");
+  Ipv4InterfaceContainer i0i1 = ipv4.Assign(devices1);
+
+  ipv4.SetBase("191.168.1.0", "255.255.255.0");
+  Ipv4InterfaceContainer i1i2 = ipv4.Assign(devices2);
+
+  Ipv4GlobalRoutingHelper::PopulateRoutingTables();
+
+  /////////////////////////////////////////
+  // Create apps.
+  NS_LOG_INFO("Creating applications.");
+  NS_LOG_INFO("  Bulk send.");
+
+  // Well-known port for server.
+  uint16_t port = 911;  
+
+  // Source (at node 0).
+  BulkSendHelper source("ns3::TcpSocketFactory",
+                        InetSocketAddress(i1i2.GetAddress(1), port));
+  // Set the amount of data to send in bytes (0 for unlimited).
+  source.SetAttribute("MaxBytes", UintegerValue(0));
+  source.SetAttribute("SendSize", UintegerValue(VZ_PACKET_SIZE));
+  ApplicationContainer apps = source.Install(nodes.Get(0));
+  apps.Start(Seconds(VZ_START_TIME));
+  apps.Stop(Seconds(VZ_STOP_TIME));
+
+  // Sink (at node 2).
+  PacketSinkHelper sink("ns3::TcpSocketFactory",
+                        InetSocketAddress(Ipv4Address::GetAny(), port));
+  apps = sink.Install(nodes.Get(2));
+  apps.Start(Seconds(VZ_START_TIME));
+  apps.Stop(Seconds(VZ_STOP_TIME));
+  Ptr<PacketSink> p_sink = DynamicCast<PacketSink> (apps.Get(0)); // 4 stats
+
+  /////////////////////////////////////////
+  // Setup tracing (as appropriate).
+  if (VZ_ENABLE_TRACE) {
+    NS_LOG_INFO("Enabling trace files.");
+    AsciiTraceHelper ath;
+    p2p.EnableAsciiAll(ath.CreateFileStream("trace.tr"));
+  }  
+  if (VZ_ENABLE_PCAP) {
+    NS_LOG_INFO("Enabling pcap file.");
+    p2p.EnablePcapAll("shark", true);
+  }
+
+  /////////////////////////////////////////
+  // Run simulation.
+  Simulator::Stop(Seconds(VZ_STOP_TIME));
+  NS_LOG_INFO("Simulation time: [" << 
+              VZ_START_TIME << "," <<
+              VZ_STOP_TIME << "]");
+  NS_LOG_INFO("--------------------------------------------");
+  Simulator::Run();
+  NS_LOG_INFO("--------------------------------------------");
+
+  /////////////////////////////////////////
+  // Ouput stats.
+  NS_LOG_INFO("Total bytes received: " << p_sink->GetTotalRx());
+  double tput = p_sink->GetTotalRx() / (VZ_STOP_TIME - VZ_START_TIME);
+  tput *= 8;          // Convert to bits.
+  tput /= 1000000.0;  // Convert to Mb/s
+  NS_LOG_INFO("Throughput: " << tput << " Mb/s");
+  NS_LOG_INFO("Done.");
+
+  // Done.
+  Simulator::Destroy();
+  return 0;
+}
diff -rupN ns-allinone-3.27/ns-3.27/examples/bbr-tests/wscript ns-allinone-3.27-bbr/ns-3.27/examples/bbr-tests/wscript
--- ns-allinone-3.27/ns-3.27/examples/bbr-tests/wscript	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-3.27-bbr/ns-3.27/examples/bbr-tests/wscript	2018-01-30 18:00:30.026856032 -0500
@@ -0,0 +1,8 @@
+## -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*-
+
+def build(bld):
+    
+    obj = bld.create_ns3_program('bulk',
+                                ['point-to-point', 'applications', 'internet'])
+    obj.source = 'bulk.cc'
+
diff -rupN ns-allinone-3.27/ns-3.27/src/applications/model/bulk-send-application.cc ns-allinone-3.27-bbr/ns-3.27/src/applications/model/bulk-send-application.cc
--- ns-allinone-3.27/ns-3.27/src/applications/model/bulk-send-application.cc	2017-10-11 16:39:00.000000000 -0400
+++ ns-allinone-3.27-bbr/ns-3.27/src/applications/model/bulk-send-application.cc	2018-01-30 18:13:28.361149078 -0500
@@ -30,6 +30,7 @@
 #include "ns3/trace-source-accessor.h"
 #include "ns3/tcp-socket-factory.h"
 #include "bulk-send-application.h"
+#include "ns3/tcp-socket-base.h" // For pacing configuration.
 
 namespace ns3 {
 
@@ -75,9 +76,16 @@ BulkSendApplication::GetTypeId (void)
 BulkSendApplication::BulkSendApplication ()
   : m_socket (0),
     m_connected (false),
-    m_totBytes (0)
+    m_totBytes (0),
+    m_to_send (0),              // For pacing
+    m_pacing_event ()           // For pacing
 {
   NS_LOG_FUNCTION (this);
+
+  if (PACING_CONFIG == APP_PACING)
+    NS_LOG_INFO ("APP_PACING. No pacing in TCP. This app *will do* pacing.");
+  else
+    NS_LOG_INFO ("This application will *not* do pacing.");
 }
 
 BulkSendApplication::~BulkSendApplication ()
@@ -182,6 +190,29 @@ void BulkSendApplication::SendData (void
   while (m_maxBytes == 0 || m_totBytes < m_maxBytes)
     { // Time to send more
 
+      // IF APPLICATION PACING
+      if (PACING_CONFIG == APP_PACING) {
+
+        // If no pacing rate set, normal (non-paced) code will handle.
+        if (GetPacingRate() == 0.0) { 
+
+          NS_LOG_INFO (this << " Pacing rate is 0 - not pacing send.");
+
+        } else {
+
+          m_to_send += 1;
+
+          // If previous timer expired, send immediately.
+          if (m_pacing_event.IsExpired()) {
+            NS_LOG_INFO (this << " Timer expired.  Send now.");
+            PaceSend();
+          }
+
+          return;
+        }
+
+      } 
+      
       // uint64_t to allow the comparison later.
       // the result is in a uint32_t range anyway, because
       // m_sendSize is uint32_t.
@@ -207,7 +238,9 @@ void BulkSendApplication::SendData (void
         {
           break;
         }
-    }
+ 
+    } // End of while() time to send more.
+
   // Check if time to close (all sent)
   if (m_totBytes == m_maxBytes && m_connected)
     {
@@ -215,7 +248,7 @@ void BulkSendApplication::SendData (void
       m_connected = false;
     }
 }
-
+  
 void BulkSendApplication::ConnectionSucceeded (Ptr<Socket> socket)
 {
   NS_LOG_FUNCTION (this << socket);
@@ -241,5 +274,91 @@ void BulkSendApplication::DataSend (Ptr<
 }
 
 
+////////////////////////////////////////////////////////
+// ADDED TO SUPPORT PACING - Start
+
+// Send packet and set timer for subsequent send.
+void BulkSendApplication::PaceSend() {
+  NS_LOG_FUNCTION (this);
 
+  // If not connected, cannot send.
+  if (!m_connected) {
+    NS_LOG_WARN (this << "  BulkSendApplication is not connected!");
+    return;
+  }
+
+  // If pacing timer expired, but device wasn't ready,
+  // there may be nothing to send.
+  if (m_to_send == 0) {
+    NS_LOG_INFO (this << "  No packets to send");
+    return;
+  } else
+    NS_LOG_INFO (this << "  packets to send: " << m_to_send);
+
+  // Prepare to send packet.
+  NS_LOG_INFO (this << "  Sending packet at " << Simulator::Now());
+  uint64_t size = m_sendSize;
+
+  // Make sure we don't send too many bytes.
+  if (m_maxBytes > 0)
+    size = std::min(size, m_maxBytes - m_totBytes);
+
+  NS_LOG_INFO (this <<
+               "  m_sendSize: " << m_sendSize <<
+               "  m_maxBytes: " << m_maxBytes <<
+               "  m_totBytes: " << m_totBytes <<
+               "  size: " << size);
+
+  // Create packet.
+  Ptr<Packet> packet = Create<Packet>(size);
+
+  // Send packet.
+  int actual = m_socket->Send(packet);
+  m_to_send -= 1;
+  
+  // Record stats.
+  if (actual > 0) {
+    m_totBytes += actual;
+    m_txTrace(packet);
+  }
+
+  // If all sent --> close connection.
+  if (m_totBytes == m_maxBytes && m_connected) {
+    m_socket->Close();
+    m_connected = false;
+  }
+
+  // Schedule next send event based on pacing rate.
+  double pacing_rate = GetPacingRate();
+  if (pacing_rate > 0) {
+    double sz = size * 8 / 1000000.0;  // Convert to Mbits.
+    double delta = sz / pacing_rate;   // Convert to seconds.
+    delta *= 1000000000;               // Convert to nanoseconds.
+    m_pacing_event.Cancel();           // Cancel any pending events.
+    m_pacing_event = Simulator::Schedule(Time(delta),
+                                         &BulkSendApplication::PaceSend, this);
+    NS_LOG_INFO (this <<
+                 "  sz: " << sz/8*1000000 <<
+                 "  rate: " << pacing_rate <<
+                 "  delta: " << delta/1000000000 <<
+                 "  @time: " << Time(Simulator::Now()+delta).GetSeconds());
+  } else
+    NS_LOG_INFO (this << " rate: " << pacing_rate << " (not pacing)");  
+  
+}
+
+// Get pacing rate from TCP socket base.
+double BulkSendApplication::GetPacingRate() const {
+  
+  // Since must be NS3_SOCK_STREAM (TCP), get the TCP socket base.
+  TcpSocketBase *p_temp = dynamic_cast <TcpSocketBase *>(GetPointer(m_socket));
+  NS_ASSERT(p_temp != NULL);
+  Ptr<TcpSocketBase> tcp_socket_base = p_temp;
+
+  return  tcp_socket_base -> GetPacingRate();
+}
+  
+// ADDED TO SUPPORT PACING - End
+////////////////////////////////////////////////////////
+  
 } // Namespace ns3
diff -rupN ns-allinone-3.27/ns-3.27/src/applications/model/bulk-send-application.h ns-allinone-3.27-bbr/ns-3.27/src/applications/model/bulk-send-application.h
--- ns-allinone-3.27/ns-3.27/src/applications/model/bulk-send-application.h	2017-10-11 16:39:00.000000000 -0400
+++ ns-allinone-3.27-bbr/ns-3.27/src/applications/model/bulk-send-application.h	2018-01-30 18:13:32.233160517 -0500
@@ -137,6 +137,22 @@ private:
    * \brief Send more data as soon as some has been transmitted.
    */
   void DataSend (Ptr<Socket>, uint32_t); // for socket's SetSendCallback
+
+////////////////////////////////////////////////////////
+// ADDED TO SUPPORT PACING - Start
+private:
+  // Get pacing rate from TCP socket base.
+  double GetPacingRate() const;
+
+  // Send packet and set timer for subsequent send.
+  void PaceSend();
+
+  int          m_to_send;          // Number of packets needing to be sent.
+  EventId      m_pacing_event;     // Pacing event.
+
+// ADDED TO SUPPORT PACING - End
+////////////////////////////////////////////////////////
+
 };
 
 } // namespace ns3
diff -rupN ns-allinone-3.27/ns-3.27/src/internet/model/tcp-bbr.cc ns-allinone-3.27-bbr/ns-3.27/src/internet/model/tcp-bbr.cc
--- ns-allinone-3.27/ns-3.27/src/internet/model/tcp-bbr.cc	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-3.27-bbr/ns-3.27/src/internet/model/tcp-bbr.cc	2018-01-30 18:13:56.141231151 -0500
@@ -0,0 +1,470 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2017 WPI, Verizon
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+// System includes.
+#include <iostream>
+
+// NS includes.
+#include "ns3/log.h"
+#include "ns3/simulator.h"
+#include "tcp-socket-base.h"          // For pacing configuration options.
+
+// BBR' includes.
+#include "rtt-estimator.h"
+#include "tcp-bbr.h"
+
+using namespace ns3;
+
+// Logging components. 
+NS_LOG_COMPONENT_DEFINE("TcpBbr");
+NS_OBJECT_ENSURE_REGISTERED(TcpBbr);
+
+// Default constructor.
+TcpBbr::TcpBbr(void) :
+  TcpCongestionOps(),
+  m_pacing_gain(0.0),
+  m_cwnd_gain(0.0),
+  m_bytes_in_flight(0),
+  m_min_rtt_change(Time(0)),
+  m_machine(this),
+  m_state_startup(this),
+  m_state_drain(this),
+  m_state_probe_bw(this),
+  m_state_probe_rtt(this) {
+
+  NS_LOG_FUNCTION(this);
+  NS_LOG_INFO(this << "  BBR' version: v" << bbr::VERSION);
+
+  // Constants in "tcp-bbr.h"
+  NS_LOG_INFO(this << "  INIT_RTT: " << bbr::INIT_RTT.GetSeconds() << " sec");
+  NS_LOG_INFO(this << "  INIT_BW: " << bbr::INIT_BW << " Mb/s");
+  NS_LOG_INFO(this << "  BW_WINDOW_TIME: " << bbr::BW_WINDOW_TIME << " rtts");
+  NS_LOG_INFO(this << "  MIN_CWND: " << bbr::MIN_CWND << " packets");
+  NS_LOG_INFO(this << "  STARTUP_THRESHOLD: " << bbr::STARTUP_THRESHOLD);
+  NS_LOG_INFO(this << "  STARTUP_GAIN: " << bbr::STARTUP_GAIN);
+  NS_LOG_INFO(this << "  STEADY_FACTOR: " << bbr::STEADY_FACTOR);
+  NS_LOG_INFO(this << "  PROBE_FACTOR: " << bbr::PROBE_FACTOR);
+  NS_LOG_INFO(this << "  DRAIN_FACTOR: " << bbr::DRAIN_FACTOR);
+  NS_LOG_INFO(this << "  PACING_FACTOR: " << bbr::PACING_FACTOR);
+
+  // Constant in "tcp-socket-base.h"
+  if (PACING_CONFIG == NO_PACING) 
+    NS_LOG_INFO(this << "  Note: BBR' configured with pacing NO_PACING.");
+
+  // First state is STARTUP.
+  m_machine.changeState(&m_state_startup);
+}
+
+// Copy constructor.
+TcpBbr::TcpBbr(const TcpBbr &sock) :
+  TcpCongestionOps(sock),
+  m_pacing_gain(0.0),
+  m_cwnd_gain(0.0),
+  m_bytes_in_flight(0),
+  m_min_rtt_change(Time(0)),
+  m_machine(this),
+  m_state_startup(this),
+  m_state_drain(this),
+  m_state_probe_bw(this),
+  m_state_probe_rtt(this) {  
+  NS_LOG_FUNCTION("[copy constructor]" << this << &sock);
+}
+
+// Default destructor.
+TcpBbr::~TcpBbr(void) {
+  NS_LOG_FUNCTION(this);
+}
+
+// Get type id.
+TypeId TcpBbr::GetTypeId(void) {
+  static TypeId tid = TypeId("ns3::TcpBbr")
+    .SetParent<TcpCongestionOps>()
+    .SetGroupName("Internet")
+    .AddConstructor<TcpBbr>();
+  return tid;
+}
+
+// Get name of congestion control algorithm.
+std::string TcpBbr::GetName() const {
+  NS_LOG_FUNCTION(this);
+  return "TcpBbr";
+}
+
+// Copy BBR' congestion control algorithm across socket.
+Ptr<TcpCongestionOps> TcpBbr::Fork() {
+  NS_LOG_FUNCTION(this);
+  return CopyObject<TcpBbr> (this);
+}
+
+// BBR' ignores calls to increase window.
+// tcb = internal congestion state
+void TcpBbr::IncreaseWindow(Ptr<TcpSocketState> tcb, uint32_t segs_acked) {
+  NS_LOG_FUNCTION(this << tcb << segs_acked);
+  NS_LOG_INFO(this << "  Ignored.");
+  return;
+}
+
+// BBR' does not use ssthresh, so ignored.
+// tcb = transmission control block
+uint32_t TcpBbr::GetSsThresh(Ptr<const TcpSocketState> tcb,
+                             uint32_t b_in_flight) {
+  NS_LOG_FUNCTION(this << tcb << b_in_flight);
+  NS_LOG_INFO(this << "  Ignored.  Returning max (65535).");
+  return 65535;
+}
+
+// On receiving ack, store RTT and estimated BW.
+// Compute and set pacing rate.
+// tcb = transmission control block
+void TcpBbr::PktsAcked(Ptr<TcpSocketState> tcb, uint32_t packets_acked,
+                       const Time &rtt) {
+
+  NS_LOG_FUNCTION(this << packets_acked << rtt);
+
+  ////////////////////////////////////////////
+  // RTT
+  if (rtt.IsZero() || rtt.IsNegative()) {
+    NS_LOG_WARN("RTT measured is zero (or less)! Not stored.");
+    return;
+  }
+
+  // See if changed minimum RTT (to decide when to PROBE_RTT).
+  Time now = Simulator::Now();
+  Time min_rtt = getRTT();
+  if (rtt < getRTT()) {
+    NS_LOG_INFO(this << "  New min RTT: " << 
+                rtt << " sec (was: " << min_rtt.GetSeconds() << ")");
+    m_min_rtt_change = now;  
+  }
+
+  // Add to RTT window.
+  m_rtt_window[now] = rtt;
+
+  // Upon first RTT, call update() to initialize timer.
+  if (m_rtt_window.size() == 1) {
+    NS_LOG_INFO(this << "  First rtt, calling update() to init.");
+    m_machine.update();
+  }
+
+  ////////////////////////////////////////////
+  // BW ESTIMATION
+  // Based on [CCYJ17b]:
+  // Cheng et al., "Delivery Rate Estimation", IETF Draft, Jul 3, 2017
+  //
+  // Send() for W_s:                       (outstanding)
+  //   Have TCP Window, (latest acked) W_a [W_1 ... W_n] W_s (next sent)
+  //   Record W_a
+  //   Record time W_t
+  //   Send W_s
+  // PktsAcked() for W_s:
+  //   Record time W_t'
+  //   Compute BW: bw = (W_s - W_a) / (W_t' - W_t)
+  //   Update data structures
+
+  SequenceNumber32 ack = tcb->m_lastAckedSeq;  // W_s
+  now = Simulator::Now();                      // W_t'
+
+  // Find newest ack in window, <= current. Note, window is sorted.
+  bbr::bw_est_struct temp;
+  for (auto it = m_est_window.begin(); it != m_est_window.end(); it++)
+    if (it->sent <= ack)                       // W_a
+      temp = *it;
+
+  // Remove all acks <= current from window.
+  for (unsigned int i=0; i < m_est_window.size(); )
+    if (m_est_window[i].sent <= temp.sent) 
+      m_est_window.erase(m_est_window.begin() + i);
+    else
+      i++;
+        
+  // Estimate BW: bw = (W_s - W_a) / (W_t' - W_t)
+  double bw_est = (ack - temp.acked) /
+                  (now.GetSeconds() - temp.time.GetSeconds());
+  bw_est *= 8;          // Convert to b/s.
+  bw_est /= 1000000;    // Convert to Mb/s.
+
+  // Add to BW window.
+  m_bw_window[now] = bw_est;
+
+  // Set pacing rate (in Mb/s), adjusted by gain.
+  double pacing_rate = getBW() * m_pacing_gain;
+
+  // There may be some advantages to pacing at less than the BW.
+  // Either way, this is adjustable in the header file.
+  if (m_pacing_gain == 1)
+    pacing_rate *= bbr::PACING_FACTOR;
+  
+  if (pacing_rate < 0)
+    pacing_rate = 0.0;
+  if (PACING_CONFIG != NO_PACING)
+    tcb -> SetPacingRate(pacing_rate);
+
+  // Report data.
+  NS_LOG_INFO(this << "  W_s: " << ack);
+  NS_LOG_INFO(this << "  W_a: " << temp.acked);
+  NS_LOG_INFO(this << "  Time (W_t): " << now.GetSeconds() << " seconds");
+  NS_LOG_INFO(this << "  W_s time (W_t'): " << temp.time.GetSeconds() << " seconds");
+  NS_LOG_INFO(this << "  byte-diff: " << (ack - temp.acked));
+  NS_LOG_INFO(this << "  time-diff: " << (now.GetSeconds() - temp.time.GetSeconds()));
+  
+  NS_LOG_INFO(this << "  bw: " << bw_est);
+  
+  NS_LOG_INFO(this << "  DATA rtt: " << rtt.GetSeconds() << "  " <<
+              "pacing-gain " << m_pacing_gain <<  "  " <<
+              "pacing-rate " << pacing_rate << " Mb/s  " <<
+              "bw: " << bw_est << " Mb/s");
+}
+
+// Before sending packet:
+// - Update TCP window
+// - Record information to estimate BW
+// tsb = tcp socket base
+// tcb = transmission control block
+void TcpBbr::Send(Ptr<TcpSocketBase> tsb, Ptr<TcpSocketState> tcb) {
+
+  NS_LOG_FUNCTION(this);
+
+  ////////////////////////////////////////////
+  // BW ESTIMATION
+  //
+  // Record information to estimate BW upon ACK (in PktsAcked()).
+  //
+  // Based on [CCYJ17b]:
+  // Based on:
+  // Cheng et al., "Delivery Rate Estimation", IETF Draft, Jul 3, 2017
+  //
+  // Send() for W_s:                       (outstanding)
+  //   Have TCP Window, (latest acked) W_a [W_1 ... W_n] W_s (next sent)
+  //   Record W_a
+  //   Record time W_t
+  //   Send W_s
+  // PktsAcked() for W_s:
+  //   Record time W_t'
+  //   Compute BW: bw = (W_s - W_a) / (W_t' - W_t)
+  //   Update data structures
+
+  // Get the bytes in flight (needed for STARTUP).
+  m_bytes_in_flight = tsb -> BytesInFlight();
+
+  // Get last sequence number acked.
+  bbr::bw_est_struct bw_est;
+  bw_est.acked = tcb -> m_lastAckedSeq;
+  bw_est.sent = tcb -> m_nextTxSequence;
+  bw_est.time = Simulator::Now();
+  m_est_window.push_back(bw_est);
+  
+  NS_LOG_INFO(this << "  Last acked seq: " << bw_est.acked);
+  NS_LOG_INFO(this << "     Sending seq: " << bw_est.sent);
+
+  double cwnd;
+  double bdp = 0.0;
+
+  ////////////////////////////////////////////
+  // SET TCP CONGESTION WINDOW (CWND).
+  
+  // Special case: if in PROBE_RTT state, set window to minimum.
+  if (m_machine.getStateType() == bbr::PROBE_RTT_STATE) {
+
+    cwnd = bbr::MIN_CWND * 1500; // In bytes.
+    NS_LOG_INFO(this << "  In PROBE_RTT. Window min: " << bbr::MIN_CWND << " pkts");
+
+  } else {
+
+    // Compute TCP cwnd based on BDP and gain.
+    bdp = getBDP();
+    if (PACING_CONFIG == NO_PACING)
+      // If no pacing, cwnd is used to control pace.
+      cwnd = bdp * m_pacing_gain;
+    else
+      // If pacing, cwnd adjusted larger.
+      cwnd = bdp * m_cwnd_gain;
+    cwnd = cwnd * 1000000 / 8; // Mbits to bytes.
+
+    // Make sure cwnd not too small (roughly, 4 packets).
+    if ((cwnd / 1500) < bbr::MIN_CWND) {
+      NS_LOG_INFO(this << "  Boosting cwnd to 4 x 1500B packets.");
+      cwnd = bbr::MIN_CWND * 1500; // In bytes.
+    }
+
+  }
+
+  // Set cwnd (in bytes).
+  tcb -> m_cWnd = (uint32_t) cwnd;
+
+  NS_LOG_INFO(this << "  DATA " <<
+              "bdp: " << bdp << " (Mb), " << bdp * 1000000/8 << " (B)  " <<
+              "cwnd-gain " << m_cwnd_gain <<  "  " <<
+              "cwnd " << cwnd << " (B)  "
+              "bytes-in-flight " <<  m_bytes_in_flight);
+}
+
+// Return bandwidth (maximum of window, in Mb/s).
+// Return -1 if no BW estimates.
+double TcpBbr::getBW() const {
+  double max_bw = 0;
+
+  NS_LOG_FUNCTION(this);
+
+  if (m_bw_window.size() == 0)
+
+    // Special case if no BW estimates.
+    max_bw = -1.0;
+
+  else
+
+    // Find max BW in window.
+    for (auto it = m_bw_window.begin(); it != m_bw_window.end(); it++)
+      max_bw = std::max(max_bw, it->second);
+  
+  NS_LOG_INFO(this << "  DATA bws in window: " << m_bw_window.size() <<
+              "  max_bw: " << max_bw);
+
+  // Return it.
+  return max_bw;
+}
+
+// Return round-trip time (min of window, in seconds).
+// Return -1 if no RTT estimates.
+Time TcpBbr::getRTT() const {
+  Time min_rtt = Time::Max();
+
+  NS_LOG_FUNCTION(this);
+
+  if (m_rtt_window.size() == 0)
+
+    // Special case if no RTT estimates.
+    min_rtt = Time(-1.0);
+
+  else
+    
+    // Find minimum RTT in window.
+    for (auto it = m_rtt_window.begin(); it != m_rtt_window.end(); it++)
+      min_rtt = std::min(min_rtt, it->second);
+
+  NS_LOG_INFO(this << "  DATA rtts in window: " << m_rtt_window.size() <<
+              "  min_rtt: " << min_rtt.GetSeconds());
+
+  // Return it.
+  return min_rtt;
+}
+
+// Return bandwidth-delay product (in Mbits).
+double TcpBbr::getBDP() const {
+  NS_LOG_FUNCTION(this);
+  Time rtt = getRTT();
+  if (rtt.IsNegative())
+    rtt = bbr::INIT_RTT;
+  double bw = getBW();
+  if (bw < 0)
+    bw = bbr::INIT_BW;
+  return (double) (rtt.GetSeconds() * bw);
+}
+
+// Remove BW estimates that are too old (greater than 10 RTTs).
+void TcpBbr::cullBWwindow() {
+
+  NS_LOG_FUNCTION(this);
+
+  // If no BW estimates, leave window unchanged.
+  double bw = getBW();
+  if (bw < 0)
+    return;
+
+  // If no RTT estimates, leave window unchanged.
+  Time rtt = getRTT();
+  if (rtt.IsNegative())
+    return;
+
+  // Compute time delta, 10 RTTs ago until now.
+  Time now = Simulator::Now();
+  Time delta = now - rtt * bbr::BW_WINDOW_TIME;
+
+  // Erase any values that are too old.
+  auto it = m_bw_window.begin();
+  while (it != m_bw_window.end()) {
+    if (it -> first < delta)
+      it = m_bw_window.erase(it);
+    else
+      it++;
+  }
+ 
+  int size = m_bw_window.size();
+  if (size == 0)
+    NS_LOG_INFO(this << " BW window empty.");
+  else
+    NS_LOG_INFO(this << " DATA" <<
+                "  m_bw_window_size: " << size <<
+                " [" << m_bw_window.begin()->first.GetSeconds() << ", " <<
+                m_bw_window.rbegin()->first.GetSeconds() << "]");
+}
+
+// Remove RTT estimates that are too old (greater than 10 seconds).
+void TcpBbr::cullRTTwindow() {
+
+  NS_LOG_FUNCTION(this);
+
+  // If no RTT estimates, leave window unchanged.
+  Time rtt = getRTT();
+  if (rtt.IsNegative())
+    return;
+
+  // Compute time delta, 10 seconds ago until now.
+  Time now = Simulator::Now();
+  Time delta = Time(now - bbr::RTT_WINDOW_TIME * 1000000000.0); // Units are nanoseconds.
+
+  // Erase any values that are too old.
+  auto it = m_rtt_window.begin();
+  while (it != m_rtt_window.end()) {
+    if (it -> first < delta)
+      it = m_rtt_window.erase(it);
+    else
+      it++;
+  }
+ 
+  int size = m_rtt_window.size();
+  if (size == 0)
+    NS_LOG_INFO(this << " RTT window empty.");
+  else
+    NS_LOG_INFO(this << " DATA" <<
+                "  m_rtt_window_size: " << size <<
+                " [" << m_rtt_window.begin()->first.GetSeconds() << ", " <<
+                m_rtt_window.rbegin()->first.GetSeconds() << "]");
+}
+
+// Return true if should enter PROBE_RTT state.
+bool TcpBbr::checkProbeRTT() {
+
+  NS_LOG_FUNCTION(this);
+
+  // In PROBE_BW state and min RTT hasn't changed in 10 seconds.
+  Time now = Simulator::Now();
+  if (m_machine.getStateType() == bbr::PROBE_BW_STATE &&
+      (now.GetSeconds() - m_min_rtt_change.GetSeconds()) > 10) {
+
+    NS_LOG_INFO(this << "  min RTT last changed: " << m_min_rtt_change.GetSeconds());
+
+    m_min_rtt_change = now;
+
+    return true;
+  }
+
+  return false;
+}
+  
+
diff -rupN ns-allinone-3.27/ns-3.27/src/internet/model/tcp-bbr.h ns-allinone-3.27-bbr/ns-3.27/src/internet/model/tcp-bbr.h
--- ns-allinone-3.27/ns-3.27/src/internet/model/tcp-bbr.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-3.27-bbr/ns-3.27/src/internet/model/tcp-bbr.h	2018-01-30 18:13:58.165237133 -0500
@@ -0,0 +1,149 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2017 WPI, Verizon
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef TCP_BBR_H
+#define TCP_BBR_H
+
+#include "tcp-congestion-ops.h"       
+#include "tcp-bbr-state.h"            
+
+namespace ns3 {
+
+namespace bbr {
+
+// Constants.
+const float VERSION = 1.3;            // See changelog.txt.
+const Time INIT_RTT = Time(1000000);  // Nanoseconds (.001 sec).
+const double INIT_BW = 6.0;           // Mb/s. 
+const int RTT_WINDOW_TIME = 10;       // In seconds.
+const int BW_WINDOW_TIME = 10;        // In RTTs.
+const int MIN_CWND = 4;               // In packets.
+const float PACING_FACTOR = 0.95;     // Factor of BW to pace (for tuning).
+  
+// PROBE_BW state:
+// Gain rates per cycle: [1.25, 0.75, 1, 1, 1, 1, 1, 1]
+const float STEADY_FACTOR = 1.0;      // Steady rate adjustment.
+const float PROBE_FACTOR = 0.25;      // Add when probe.
+const float DRAIN_FACTOR = 0.25;      // Decrease when drain.
+  
+// STARTUP state:
+const float STARTUP_THRESHOLD = 1.25; // Threshold to exit STARTUP.
+const float STARTUP_GAIN = 2.89;      // Roughly 2/ln(2).
+
+// Structure for tracking TCP window for estimating BW.
+struct bw_est_struct {
+  SequenceNumber32 acked;  // Last sequence number acked.
+  SequenceNumber32 sent;   // Next sequence number sent.
+  Time time;               // Time sent.
+};
+
+} // end of namespace bbr
+  
+  
+/**
+ * \ingroup congestionOps
+ *
+ * \brief Implementation of basic TCP BBR' functionality.
+ *
+ */
+class TcpBbr : public TcpCongestionOps {
+
+public:
+
+  friend class BbrState;
+  friend class BbrStartupState;
+  friend class BbrDrainState;
+  friend class BbrProbeBWState;
+  friend class BbrProbeRTTState;
+  friend class BbrStateMachine;
+
+  // Get type id.
+  static TypeId GetTypeId(void);
+
+  // Get name of congestion control algorithm.
+  std::string GetName() const;
+
+  // Default constructor.
+  TcpBbr();
+
+  // Copy constructor.
+  TcpBbr(const TcpBbr &sock);
+
+  // Destructor.
+  virtual ~TcpBbr();
+
+  // Before sending packet:
+  // - Update TCP window
+  // - Record information to estimate BW
+  virtual void Send(Ptr<TcpSocketBase> tsb, Ptr<TcpSocketState> tcb);
+
+  // On receiving ack, store RTT and estimated BW.
+  // Compute and set pacing rate.
+  virtual void PktsAcked(Ptr<TcpSocketState> tcb, uint32_t packets_acked,
+                         const Time &rtt);
+
+  // Copy BBR' congestion control with copy.
+  virtual Ptr<TcpCongestionOps> Fork();
+
+  // BBR' ignores calls to increase window.
+  virtual void IncreaseWindow(Ptr<TcpSocketState> tcb, uint32_t segs_acked);
+
+  // BBR' does not use ssthresh, so ignored.
+  virtual uint32_t GetSsThresh(Ptr<const TcpSocketState> tcb, uint32_t b_in_flight);
+
+private:
+  
+  // Check if should enter PROBE_RTT state.
+  bool checkProbeRTT();
+
+  // Return bandwidth-delay product (in Mbits).
+  double getBDP() const;
+
+  // Return round-trip time (min of window, in seconds).
+  // Return -1 if no RTT estimates yet.
+  Time getRTT() const;
+
+  // Return bandwidth (max of window, in Mb/s).
+  // Return -1 if no BW estimates yet.
+  double getBW() const;
+
+  // Remove BW estimates that are too old (greater than 10 RTTs).
+  void cullBWwindow();
+
+  // Remove RTT estimates that are too old (greater than 10 seconds).
+  void cullRTTwindow();
+
+protected:
+  double m_pacing_gain;                    // Scale estimated BDP for pacing rate.
+  double m_cwnd_gain;                      // Scale estimated BDP for cwnd.
+  std::map<Time, Time> m_rtt_window;       // For computing min RTT at sender.
+  std::map<Time, double> m_bw_window;      // For computing max BW at sender.
+  std::vector<bbr::bw_est_struct> m_est_window; // For estimating BW from ACKs.
+  uint32_t m_bytes_in_flight;              // Bytes in flight (from socket base).
+  Time m_min_rtt_change;                   // Last time min RTT changed.
+  BbrStateMachine m_machine;               // State machine.
+  BbrStartupState m_state_startup;         // STARTUP state.
+  BbrDrainState m_state_drain;             // DRAIN state.
+  BbrProbeBWState m_state_probe_bw;        // PROBE_BW state.
+  BbrProbeRTTState m_state_probe_rtt;      // PROBE_RTT state.
+};
+
+} // end of namespace ns3
+
+#endif // TCP_BBR_H
diff -rupN ns-allinone-3.27/ns-3.27/src/internet/model/tcp-bbr-state.cc ns-allinone-3.27-bbr/ns-3.27/src/internet/model/tcp-bbr-state.cc
--- ns-allinone-3.27/ns-3.27/src/internet/model/tcp-bbr-state.cc	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-3.27-bbr/ns-3.27/src/internet/model/tcp-bbr-state.cc	2018-01-30 18:13:56.141231151 -0500
@@ -0,0 +1,473 @@
+//
+// BbrState.cpp
+//
+// State machine and states for TcpBbr.
+//
+
+// Include files.
+#include "ns3/log.h"
+#include "tcp-bbr.h"
+#include "tcp-bbr-state.h"
+
+using namespace ns3;
+
+NS_LOG_COMPONENT_DEFINE("BbrState");
+NS_OBJECT_ENSURE_REGISTERED(BbrState);
+
+///////////////////////////////////////////////
+// BBR' State Machine
+// Executes current state through update().
+// Changes state through exit() and enter().
+
+// Update state: STARTUP, DRAIN, PROBE_BW, PROBE_RTT.
+//
+//  State transition diagram:
+//          |
+//          V
+//       STARTUP  
+//          |     
+//          V     
+//        DRAIN   
+//          |     
+//          V     
+// +---> PROBE_BW ----+
+// |      ^    |      |
+// |      |    |      |
+// |      +----+      |
+// |                  |
+// +---- PROBE_RTT <--+
+
+// Default constructor.
+BbrStateMachine::BbrStateMachine() {
+  NS_LOG_FUNCTION(this);
+  m_owner = NULL;
+  m_state = NULL;
+}
+
+// Default constructor.
+BbrStateMachine::BbrStateMachine(TcpBbr *owner) {
+  NS_LOG_FUNCTION(this);
+  m_owner = owner;
+  m_state = NULL;
+}
+
+// Get type id.
+TypeId BbrStateMachine::GetTypeId(void) {
+  static TypeId tid = TypeId("ns3::BbrStateMachine")
+    .SetParent<Object>()
+    .SetGroupName("Internet")
+    .AddConstructor<BbrStateMachine>();
+  return tid;
+}
+
+// Get name of object.
+std::string BbrStateMachine::GetName() const {
+  NS_LOG_FUNCTION(this);
+  return "BbrStateMachine";
+}
+
+// Get type of current state.
+bbr::bbr_state BbrStateMachine::getStateType() const {
+  return m_state -> getType();
+}
+
+// Update by executing current state.
+void BbrStateMachine::update() {
+  NS_LOG_FUNCTION(this);
+
+  if (m_state == NULL) {
+    NS_LOG_INFO(this << " m_state NULL. Probably flow terminated, so ok.");
+    return;
+  }
+
+  NS_LOG_INFO(this << "  State: " << m_state -> GetName());
+
+  // Check if should enter PROBE_RTT.
+  if (m_owner -> checkProbeRTT())
+    changeState(&m_owner -> m_state_probe_rtt);
+
+  // Execute current state.
+  m_state -> execute();
+
+  // Cull RTT window.
+  m_owner -> cullRTTwindow();
+
+  // Cull BW window (except in DRAIN state).
+  m_owner -> cullBWwindow();
+
+  // Schedule next event (if we can).
+  Time rtt = m_owner -> getRTT();
+  if (!rtt.IsNegative()) {
+    Simulator::Schedule(rtt, &BbrStateMachine::update, this);
+    NS_LOG_INFO(this << "  Next event: " << rtt.GetSeconds());
+  } else // update() will be called in PktsAcked() upon getting first rtt.
+    NS_LOG_INFO(this << "  Not scheduling next event.");
+}
+
+// Change current state to new state.
+void BbrStateMachine::changeState(BbrState *new_state) {
+  NS_LOG_FUNCTION(this);
+  NS_ASSERT(new_state != NULL);
+  if (m_state)
+    NS_LOG_INFO(this <<
+		"  Old: " << m_state -> GetName() <<
+		"  New: " << new_state -> GetName());
+  else
+    NS_LOG_INFO(this << " Initial state: " << new_state -> GetName());
+
+  // Call exit on old state.
+  if (m_state)
+    m_state -> exit();
+
+  // Change to new state.
+  m_state = new_state;
+
+  // Call enter on new state.
+  m_state -> enter();
+}
+
+///////////////////////////////////////////////
+// BBR' State
+
+BbrState::BbrState(TcpBbr *owner) {
+  m_owner = owner;
+}
+
+BbrState::BbrState() {
+  m_owner = NULL;
+}
+
+BbrState::~BbrState() {
+}
+
+// Get type id.
+TypeId BbrState::GetTypeId(void) {
+  static TypeId tid = TypeId("ns3::BbrState")
+    .SetParent<BbrStateMachine>()
+    .SetGroupName("Internet");
+  return tid;
+}
+
+// Get name of object.
+std::string BbrState::GetName() const {
+  return "BbrState";
+}
+
+// Invoked when state first entered.
+void BbrState::enter() {
+}
+
+// Invoked when state exited.
+void BbrState::exit() {
+}
+
+///////////////////////////////////////////////
+// BBR' STARTUP
+  
+BbrStartupState::BbrStartupState(TcpBbr *owner) : BbrState(owner),
+  m_full_bw(0),
+  m_full_bw_count(0) {
+  NS_LOG_FUNCTION(this);
+}
+
+BbrStartupState::BbrStartupState() : BbrState(),
+  m_full_bw(0),
+  m_full_bw_count(0) {
+  NS_LOG_FUNCTION(this);
+}
+
+// Get type id.
+TypeId BbrStartupState::GetTypeId(void) {
+  static TypeId tid = TypeId("ns3::BbrStartupState")
+    .SetParent<BbrStateMachine>()
+    .SetGroupName("Internet")
+    .AddConstructor<BbrStartupState>();
+  return tid;
+}
+
+// Get name of object.
+std::string BbrStartupState::GetName() const {
+  return "BbrStartupState";
+}
+
+// Get state type.
+bbr::bbr_state BbrStartupState::getType(void) const {
+  return bbr::STARTUP_STATE;
+}
+
+// Invoked when state first entered.
+void BbrStartupState::enter() {
+  NS_LOG_FUNCTION(this);
+
+  NS_LOG_INFO(this << " State: " << GetName());
+
+  // Set gains to 2/ln(2).
+  m_owner -> m_pacing_gain = bbr::STARTUP_GAIN;
+  m_owner -> m_cwnd_gain = bbr::STARTUP_GAIN;
+}
+
+// Invoked when state updated.
+void BbrStartupState::execute() {
+  NS_LOG_FUNCTION(this);
+
+  NS_LOG_INFO(this << " State: " << GetName());
+
+  double new_bw = m_owner -> getBW();
+
+  // If no legitimate estimates yet, no more to do.
+  if (new_bw < 0) {
+    NS_LOG_INFO(this << "  No BW estimates yet.");
+    return;
+  }
+  
+  // Still growing?
+  if (new_bw > m_full_bw * bbr::STARTUP_THRESHOLD) { 
+    NS_LOG_INFO(this << "  Still growing. old_bw: " << m_full_bw << "  new_bw: " << new_bw);
+    m_full_bw = new_bw;
+    m_full_bw_count = 0;
+    return;
+  }
+
+  // Another round w/o much growth.
+  m_full_bw_count++;
+  NS_LOG_INFO(this << "  Growth stalled. old_bw: " << m_full_bw << "  new_bw: " << new_bw << "  full-bw-count: " << m_full_bw_count);
+  
+  // If 3+ rounds w/out much growth, STARTUP --> DRAIN.
+  if (m_full_bw_count > 2) {
+    NS_LOG_INFO(this << "  Exiting STARTUP, next state DRAIN");
+    m_owner -> m_machine.changeState(&m_owner -> m_state_drain);
+  }
+
+  return;
+}
+
+///////////////////////////////////////////////
+// BBR' DRAIN
+  
+BbrDrainState::BbrDrainState(TcpBbr *owner) :
+  BbrState(owner),
+  m_inflight_limit(0),
+  m_round_count(0) {
+  NS_LOG_FUNCTION(this);
+}
+
+BbrDrainState::BbrDrainState() :
+  BbrState(),
+  m_inflight_limit(0),
+  m_round_count(0) {
+  NS_LOG_FUNCTION(this);
+}
+
+// Get type id.
+TypeId BbrDrainState::GetTypeId(void) {
+  static TypeId tid = TypeId("ns3::BbrDrainState")
+    .SetParent<BbrStateMachine>()
+    .SetGroupName("Internet")
+    .AddConstructor<BbrDrainState>();
+  return tid;
+}
+
+// Get name of object.
+std::string BbrDrainState::GetName() const {
+  return "BbrDrainState";
+}
+
+// Get state type.
+bbr::bbr_state BbrDrainState::getType(void) const {
+  return bbr::DRAIN_STATE;
+}
+
+// Invoked when state first entered.
+void BbrDrainState::enter() {
+  NS_LOG_FUNCTION(this);
+  NS_LOG_INFO(this << " State: " << GetName());
+
+  // Set pacing gain to 1/[2/ln(2)].
+  m_owner -> m_pacing_gain = 1 / bbr::STARTUP_GAIN;
+
+  // Maintain high cwnd gain.
+  if (PACING_CONFIG == NO_PACING)
+    m_owner -> m_cwnd_gain = 1 / bbr::STARTUP_GAIN; // Slow cwnd if no pacing.
+  else
+    m_owner -> m_cwnd_gain = bbr::STARTUP_GAIN; // Maintain high cwnd gain.
+
+  // Get BDP for target inflight limit when will exit STARTUUP..
+  double bdp = m_owner -> getBDP();
+  bdp = bdp * 1000000 / 8; // Convert to bytes.
+  m_inflight_limit = (uint32_t) bdp;  
+  m_round_count = 0;
+}
+
+// Invoked when state updated.
+void BbrDrainState::execute() {
+  NS_LOG_FUNCTION(this);
+
+  NS_LOG_INFO(this << " State: " << GetName());
+
+  NS_LOG_INFO(this << " " <<
+	      GetName() <<
+	      "  round: " << m_round_count <<
+	      "  bytes_in_flight: " << m_owner -> m_bytes_in_flight <<
+	      "  inflight_limit: " << m_inflight_limit);
+
+  // See if should exit DRAIN state.
+  // Do when byte-in-flight are under limit or 5 rounds
+  // have passed (2.89/(1-1/2.89) ~ 4.5), whichever is first.
+  m_round_count++;
+  if (m_owner -> m_bytes_in_flight < m_inflight_limit ||
+      m_round_count == 5) {
+    NS_LOG_INFO(this << " Exiting DRAIN, next state PROBE_BW");
+    m_owner -> m_machine.changeState(&m_owner -> m_state_probe_bw);
+  }
+}
+
+///////////////////////////////////////////////
+// BBR' PROBE_BW
+  
+BbrProbeBWState::BbrProbeBWState(TcpBbr *owner) : BbrState(owner) {
+  NS_LOG_FUNCTION(this);
+}
+
+BbrProbeBWState::BbrProbeBWState() : BbrState() {
+  NS_LOG_FUNCTION(this);
+}
+
+// Get type id.
+TypeId BbrProbeBWState::GetTypeId(void) {
+  static TypeId tid = TypeId("ns3::BbrProbeBWState")
+    .SetParent<BbrStateMachine>()
+    .SetGroupName("Internet")
+    .AddConstructor<BbrProbeBWState>();
+  return tid;
+}
+
+// Get name of object.
+std::string BbrProbeBWState::GetName() const {
+  return "BbrProbeBWState";
+}
+
+// Get state type.
+bbr::bbr_state BbrProbeBWState::getType(void) const {
+  return bbr::PROBE_BW_STATE;
+}
+
+// Invoked when state first entered.
+void BbrProbeBWState::enter() {
+  NS_LOG_FUNCTION(this);
+  NS_LOG_INFO(this << " State: " << GetName());
+
+  // Pick random start cycle phase (except "low") to avoid synch of
+  // flows that enter PROBE_BW simultaneously.
+  do {
+    m_gain_cycle = rand() % 8;
+  } while (m_gain_cycle == 1);  // Phase 1 is "low" cycle.
+
+  NS_LOG_INFO(this << " " << GetName() << " Start cycle: " << m_gain_cycle);
+
+  // Set gains based on phase.
+  m_owner -> m_pacing_gain = bbr::STEADY_FACTOR;
+  if (m_gain_cycle == 0) // Phase 0 is "high" cycle.
+    m_owner -> m_pacing_gain += bbr::PROBE_FACTOR;
+  if (PACING_CONFIG == NO_PACING)
+    m_owner -> m_cwnd_gain = m_owner -> m_pacing_gain;
+  else
+    m_owner -> m_cwnd_gain = bbr::STEADY_FACTOR * 2;
+}
+
+// Invoked when state updated.
+void BbrProbeBWState::execute() {
+  NS_LOG_FUNCTION(this);
+
+  NS_LOG_INFO(this << " " << GetName() << "  m_gain_cycle: " << m_gain_cycle);
+
+  // Set gain rate: [high, low, stdy, stdy, stdy, stdy, stdy, stdy]
+  if (m_gain_cycle == 0)
+    m_owner -> m_pacing_gain = bbr::STEADY_FACTOR + bbr::PROBE_FACTOR;
+  else if (m_gain_cycle == 1)
+    if (PACING_CONFIG == NO_PACING) 
+      m_owner -> m_pacing_gain = bbr::STEADY_FACTOR - bbr::DRAIN_FACTOR/8;
+    else
+      m_owner -> m_pacing_gain = bbr::STEADY_FACTOR - bbr::DRAIN_FACTOR;
+  else
+    m_owner -> m_pacing_gain = bbr::STEADY_FACTOR;
+
+  if (PACING_CONFIG == NO_PACING)
+    // If configed for NO_PACING, rate is controlled by cwnd at bdp.
+    m_owner -> m_cwnd_gain = m_owner -> m_pacing_gain;
+  else
+    // Otherwise, cwnd can be twice bdp.
+    m_owner -> m_cwnd_gain = 2 * bbr::STEADY_FACTOR;
+
+  // Move to next cycle, wrapping.
+  m_gain_cycle++;
+  if (m_gain_cycle > 7)
+    m_gain_cycle = 0;
+
+  NS_LOG_INFO(this << " " <<
+	      GetName() << " DATA pacing-gain: " << m_owner -> m_pacing_gain);
+}
+
+///////////////////////////////////////////////
+// BBR' PROBE_RTT
+  
+BbrProbeRTTState::BbrProbeRTTState(TcpBbr *owner) : BbrState(owner) {
+  NS_LOG_FUNCTION(this);
+}
+
+BbrProbeRTTState::BbrProbeRTTState() : BbrState() {
+  NS_LOG_FUNCTION(this);
+}
+
+// Get type id.
+TypeId BbrProbeRTTState::GetTypeId(void) {
+  static TypeId tid = TypeId("ns3::BbrProbeRTTState")
+    .SetParent<BbrStateMachine>()
+    .SetGroupName("Internet")
+    .AddConstructor<BbrProbeRTTState>();
+  return tid;
+}
+
+// Get name of object.
+std::string BbrProbeRTTState::GetName() const {
+  return "BbrProbeRTTState";
+}
+
+// Get state type.
+bbr::bbr_state BbrProbeRTTState::getType(void) const {
+  return bbr::PROBE_RTT_STATE;
+}
+
+// Invoked when state first entered.
+void BbrProbeRTTState::enter() {
+  NS_LOG_FUNCTION(this);
+  NS_LOG_INFO(this << " State: " << GetName());
+
+  // Set gains (Send() will minimize window);
+  m_owner -> m_pacing_gain = bbr::STEADY_FACTOR;
+  m_owner -> m_cwnd_gain = bbr::STEADY_FACTOR;
+
+  // Compute time when to exit: max (0.2 seconds, min RTT).
+  Time rtt = m_owner -> getRTT();
+  if (rtt.GetSeconds() > 0.2)
+    m_probe_rtt_time = rtt;
+  else
+    m_probe_rtt_time = Time(0.2 * 1000000000);
+  m_probe_rtt_time = m_probe_rtt_time + Simulator::Now();
+    
+  NS_LOG_INFO(this << " " <<
+	      GetName() << " In PROBE_RTT until: " << m_probe_rtt_time.GetSeconds());
+}
+
+// Invoked when state updated.
+void BbrProbeRTTState::execute() {
+  NS_LOG_FUNCTION(this);
+
+  NS_LOG_INFO(this << " State: " << GetName());
+
+  // If enough time elapsed, PROBE_RTT --> PROBE_BW.
+  Time now = Simulator::Now();
+  if (now > m_probe_rtt_time) {
+      NS_LOG_INFO(this << " Exiting PROBE_RTT, next state PROBE_BW");
+      m_owner -> m_machine.changeState(&m_owner -> m_state_probe_bw);
+  }
+}
diff -rupN ns-allinone-3.27/ns-3.27/src/internet/model/tcp-bbr-state.h ns-allinone-3.27-bbr/ns-3.27/src/internet/model/tcp-bbr-state.h
--- ns-allinone-3.27/ns-3.27/src/internet/model/tcp-bbr-state.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-allinone-3.27-bbr/ns-3.27/src/internet/model/tcp-bbr-state.h	2018-01-30 18:13:58.165237133 -0500
@@ -0,0 +1,213 @@
+//
+// BbrState.h
+//
+// State machine (and states) for TcpBbr.
+//
+
+#ifndef BBR_STATE_H
+#define BBR_STATE_H
+
+#include "ns3/object.h"
+#include "ns3/nstime.h"
+
+namespace ns3 {
+
+class TcpBbr; 
+class BbrState;
+
+namespace bbr {
+
+// Defined BBR' states.
+enum bbr_state {
+  UNDEFINED_STATE=-1,
+  STARTUP_STATE,
+  DRAIN_STATE,
+  PROBE_BW_STATE,
+  PROBE_RTT_STATE,
+};
+
+} // end of namespace bbr
+
+///////////////////////////////////////////////
+// BBR' State Machine
+class BbrStateMachine : public Object {
+
+ public:
+  // Get type id.
+  static TypeId GetTypeId();
+
+  // Get name of object.
+  std::string GetName() const;
+
+  // Constructor.
+  BbrStateMachine();
+  BbrStateMachine(TcpBbr *owner);
+
+  // Change state machine to new state.
+  void changeState(BbrState *p_new_state);
+
+  // Get type of current state.
+  bbr::bbr_state getStateType() const;
+
+  // Update by executing current state.
+  void update();
+
+ private:
+  BbrState *m_state;           // Current state.
+  TcpBbr *m_owner;             // BBR' flow that owns machine.
+};
+
+///////////////////////////////////////////////
+// BBR' State.
+class BbrState : public Object {
+
+ public:
+  // Get type id.
+  static TypeId GetTypeId();
+
+  // Get name of object.
+  virtual std::string GetName() const;
+  
+  // Constructors.
+  BbrState();
+  BbrState(TcpBbr *owner);
+
+  // Destructor.
+  virtual ~BbrState();
+
+  // Get state type.
+  virtual bbr::bbr_state getType() const=0;
+
+  // Invoked when state first entered.
+  virtual void enter();
+
+  // Invoked when state updated.
+  virtual void execute()=0;
+
+  // Invoked when state exited.
+  virtual void exit();
+
+ protected:
+  TcpBbr *m_owner;             // BBR' flow that owns state.
+};
+
+///////////////////////////////////////////////
+// BBR' STARTUP state
+
+class BbrStartupState : public BbrState {
+
+ public:
+  // Get type id.
+  static TypeId GetTypeId();
+
+  // Get name of object.
+  std::string GetName() const;
+  
+  // Constructors.
+  BbrStartupState(TcpBbr *owner);
+  BbrStartupState();
+
+  // Get state type.
+  bbr::bbr_state getType() const;
+
+  // Invoked when state first entered.
+  void enter();
+
+  // Invoked when state updated.
+  void execute();
+
+ private:
+  double m_full_bw;                        // Max prev BW in STARTUP.
+  int m_full_bw_count;                     // Times BW not grown in STARTUP.
+};
+
+///////////////////////////////////////////////
+// BBR' DRAIN
+
+class BbrDrainState : public BbrState {
+
+ public:
+  // Get type id.
+  static TypeId GetTypeId();
+
+  // Get name of object.
+  std::string GetName() const;
+  
+  // Constructors.
+  BbrDrainState(TcpBbr *owner);
+  BbrDrainState();
+
+  // Get state type.
+  bbr::bbr_state getType() const;
+
+  // Invoked when state first entered.
+  void enter();
+
+  // Invoked when state updated.
+  void execute();
+
+ private:
+  uint32_t m_inflight_limit; // Target bytes in flight to exit DRAIN state.
+  uint32_t m_round_count;    // Number of rounds in DRAIN state.
+};
+
+///////////////////////////////////////////////
+// BBR' PROBE_BW
+
+class BbrProbeBWState : public BbrState {
+
+ public:
+  // Get type id.
+  static TypeId GetTypeId();
+
+  // Get name of object.
+  std::string GetName() const;
+  
+  // Constructors.
+  BbrProbeBWState(TcpBbr *owner);
+  BbrProbeBWState();
+
+  // Get state type.
+  bbr::bbr_state getType() const;
+
+  // Invoked when state first entered.
+  void enter();
+
+  // Invoked when state updated.
+  void execute();
+
+ private:
+  int m_gain_cycle;                        // For cycling gain in PROBE_BW.
+};
+
+///////////////////////////////////////////////
+// BBR' PROBE_RTT
+
+class BbrProbeRTTState : public BbrState {
+
+ public:
+  // Get type id.
+  static TypeId GetTypeId();
+
+  // Get name of object.
+  std::string GetName() const;
+  
+  // Constructors.
+  BbrProbeRTTState(TcpBbr *owner);
+  BbrProbeRTTState();
+
+  // Get state type.
+  bbr::bbr_state getType() const;
+
+  // Invoked when state first entered.
+  void enter();
+
+  // Invoked when state updated.
+  void execute();
+
+ private:
+  Time m_probe_rtt_time;     // Time to remain in PROBE_RTT.
+};
+
+} // end of namespace ns3
+#endif
diff -rupN ns-allinone-3.27/ns-3.27/src/internet/model/tcp-congestion-ops.h ns-allinone-3.27-bbr/ns-3.27/src/internet/model/tcp-congestion-ops.h
--- ns-allinone-3.27/ns-3.27/src/internet/model/tcp-congestion-ops.h	2017-10-11 16:39:00.000000000 -0400
+++ ns-allinone-3.27-bbr/ns-3.27/src/internet/model/tcp-congestion-ops.h	2018-01-30 18:27:58.639686817 -0500
@@ -122,6 +122,11 @@ public:
   {
   }
 
+  // Added for BBR' support.
+  virtual void Send (Ptr<TcpSocketBase> tsb, Ptr<TcpSocketState> tcb)
+  {
+  }
+
   /**
    * \brief Trigger events/calculations specific to a congestion state
    *
diff -rupN ns-allinone-3.27/ns-3.27/src/internet/model/tcp-socket-base.cc ns-allinone-3.27-bbr/ns-3.27/src/internet/model/tcp-socket-base.cc
--- ns-allinone-3.27/ns-3.27/src/internet/model/tcp-socket-base.cc	2017-10-11 16:39:00.000000000 -0400
+++ ns-allinone-3.27-bbr/ns-3.27/src/internet/model/tcp-socket-base.cc	2018-01-30 18:14:08.093266472 -0500
@@ -250,7 +250,8 @@ TcpSocketState::TcpSocketState (void)
     // Change m_nextTxSequence for non-zero initial sequence number
     m_nextTxSequence (0),
     m_rcvTimestampValue (0),
-    m_rcvTimestampEchoReply (0)
+    m_rcvTimestampEchoReply (0),
+    m_pacing_rate (0.0) // For pacing
 {
 }
 
@@ -266,7 +267,8 @@ TcpSocketState::TcpSocketState (const Tc
     m_highTxMark (other.m_highTxMark),
     m_nextTxSequence (other.m_nextTxSequence),
     m_rcvTimestampValue (other.m_rcvTimestampValue),
-    m_rcvTimestampEchoReply (other.m_rcvTimestampEchoReply)
+    m_rcvTimestampEchoReply (other.m_rcvTimestampEchoReply),
+    m_pacing_rate (other.m_pacing_rate) // For pacing
 {
 }
 
@@ -278,6 +280,8 @@ TcpSocketState::TcpCongStateName[TcpSock
 
 TcpSocketBase::TcpSocketBase (void)
   : TcpSocket (),
+    m_pacing_event (),   // For pacing
+    m_pacing_packets (), // For pacing
     m_retxEvent (),
     m_lastAckEvent (),
     m_delAckEvent (),
@@ -335,6 +339,12 @@ TcpSocketBase::TcpSocketBase (void)
     m_isFirstPartialAck (true)
 {
   NS_LOG_FUNCTION (this);
+
+  if (PACING_CONFIG == TCP_PACING) 
+    NS_LOG_INFO("PACING_IN_TCP - Pacing in TCP is enabled.");
+  else
+    NS_LOG_INFO("APP_PACING/NO_PACING - Pacing in TCP is *not* enabled.");
+
   m_rxBuffer = CreateObject<TcpRxBuffer> ();
   m_txBuffer = CreateObject<TcpTxBuffer> ();
   m_tcb      = CreateObject<TcpSocketState> ();
@@ -364,6 +374,8 @@ TcpSocketBase::TcpSocketBase (void)
 
 TcpSocketBase::TcpSocketBase (const TcpSocketBase& sock)
   : TcpSocket (sock),
+    m_pacing_event (sock.m_pacing_event),     // For pacing
+    m_pacing_packets (sock.m_pacing_packets), // For pacing
     //copy object::m_tid and socket::callbacks
     m_dupAckCount (sock.m_dupAckCount),
     m_delAckCount (0),
@@ -2647,11 +2659,94 @@ TcpSocketBase::ConnectionSucceeded ()
 
 /* Extract at most maxSize bytes from the TxBuffer at sequence seq, add the
     TCP header, and send to TcpL4Protocol */
+// If pacing, queue until time to send else send now.
 uint32_t
 TcpSocketBase::SendDataPacket (SequenceNumber32 seq, uint32_t maxSize, bool withAck)
 {
   NS_LOG_FUNCTION (this << seq << maxSize << withAck);
 
+  // If not TCP pacing, go ahead and send normally.
+  if (PACING_CONFIG == NO_PACING || PACING_CONFIG == APP_PACING)
+    return SendDataPacketReal(seq, maxSize, withAck);
+
+  // Pacing, so queue until time to send else send now.
+  // pacing_rate: pacing rate for flow, controls inter-packet spacing.
+  double pacing_rate = m_tcb -> GetPacingRate();
+  if (pacing_rate == 0.0) {
+    NS_LOG_INFO (this << " Pacing rate is 0");
+    return SendDataPacketReal(seq, maxSize, withAck);
+  } else {
+    NS_LOG_INFO (this << " Pacing rate: " << pacing_rate);
+
+    // Store packet.
+    tcp_pacing_struct packet{seq, maxSize, withAck};
+    m_pacing_packets.push(packet);
+
+    // If no pending event, immediately schedule.
+    if (m_pacing_event.IsExpired()) {
+      m_pacing_event = Simulator::ScheduleNow(&TcpSocketBase::PacePackets, this);
+      NS_LOG_INFO (this << " Previous event expired. Scheduling immediately. event_id: " << m_pacing_event.GetUid() << "  timestamp: " << m_pacing_event.GetTs()/1000000000.0);
+    }
+
+    // Return size that would have been sent so app knows it's scheduled.
+    Ptr<Packet> p = m_txBuffer->CopyFromSequence(maxSize, seq);
+    uint32_t sz = p->GetSize(); // Size of packet
+    return sz;
+  }
+}
+
+// Send next packet in queue and set timer for subsequent send.
+void TcpSocketBase::PacePackets() {
+  double size;
+  NS_LOG_FUNCTION (this);
+
+  // If pacing queue empty, app hasn't provided more data.
+  NS_LOG_INFO (this << " Pacing packets: " << m_pacing_packets.size());
+  if (m_pacing_packets.empty()) {
+    NS_LOG_INFO (this << " Pacing list empty.");
+    size = 1000; // Temporary packet bytes for computing pacing interval.
+  } else {
+
+    // Get next packet to send.
+    tcp_pacing_struct packet = m_pacing_packets.front();
+    m_pacing_packets.pop();
+
+    // Send it.
+    SendDataPacketReal(packet.seq, packet.maxSize, packet.withAck);
+
+    // Get size for computing pacing interval.
+    size = packet.maxSize;
+  }
+
+  // Schedule next send event.
+  double pacing_rate = m_tcb -> GetPacingRate();
+  if (pacing_rate > 0) {
+    size *= 8 / 1000000.0;  // Convert to Mbits.
+    double delta = size / pacing_rate; // Convert to seconds.
+    delta *= 1000000000;  // Convert to nanoseconds.
+    m_pacing_event.Cancel();  // Cancel any pending events. Needed?
+    m_pacing_event = Simulator::Schedule(Time(delta),
+                                         &TcpSocketBase::PacePackets, this);
+    NS_LOG_INFO (this <<
+                 " event_id: " << m_pacing_event.GetUid() <<
+                 "  size: " << size/8*1000000 <<
+                 "  rate: " << pacing_rate <<
+                 "  delta: " << delta/1000000000 <<
+                 "  @time: " << Time(Simulator::Now()+delta).GetSeconds());
+  } else
+    NS_LOG_INFO (this << " rate: " << pacing_rate << " (no pacing)");  
+}
+  
+/* Really send the data packet.
+   Extract at most maxSize bytes from the TxBuffer at sequence seq, add the
+   TCP header, and send to TcpL4Protocol */
+uint32_t
+TcpSocketBase::SendDataPacketReal (SequenceNumber32 seq, uint32_t maxSize, bool withAck)
+{
+  NS_LOG_FUNCTION (this << seq << maxSize << withAck);
+
+  m_congestionControl->Send(this, m_tcb);  // Addition for BBR'.
+
   bool isRetransmission = false;
   if (seq != m_tcb->m_highTxMark)
     {
@@ -2781,6 +2876,7 @@ TcpSocketBase::SendDataPacket (SequenceN
     }
   // Update highTxMark
   m_tcb->m_highTxMark = std::max (seq + sz, m_tcb->m_highTxMark.Get ());
+
   return sz;
 }
 
@@ -2980,6 +3076,20 @@ TcpSocketBase::BytesInFlight () const
     }
 
   NS_LOG_DEBUG ("Returning calculated bytesInFlight: " << bytesInFlight);
+
+  // Compute total bytes in pacing packet queue.
+  int pacing_bytes = 0;
+  std::queue<tcp_pacing_struct> temp_q = m_pacing_packets;
+  while (!temp_q.empty()) {
+    tcp_pacing_struct packet = m_pacing_packets.front();
+    pacing_bytes += packet.maxSize;
+    temp_q.pop();
+  } 
+  NS_LOG_INFO (this << " DATA Pacing queue pkts: " << m_pacing_packets.size() << "  " << 
+               "bytes: " << pacing_bytes << "  " <<
+               "inflight: " << bytesInFlight << "  " <<
+               "inflight adjusted: " << bytesInFlight - pacing_bytes);
+
   return bytesInFlight;
 }
 
@@ -3947,4 +4057,35 @@ RttHistory::RttHistory (const RttHistory
 {
 }
 
+///////////////////////////////////////////////////////////////////
+// ADDITIONS FOR PACING: START
+
+// Get pacing rate.
+double TcpSocketState::GetPacingRate() const {
+  //NS_LOG_FUNCTION (this);
+  return m_pacing_rate;
+}    
+
+// Set pacing rate.
+void TcpSocketState::SetPacingRate(double pacing_rate) {
+  //NS_LOG_FUNCTION (this << pacing_rate);
+  m_pacing_rate = pacing_rate;
+}
+
+// Get pacing rate (in tcp socket state).
+double TcpSocketBase::GetPacingRate() const {
+  NS_LOG_FUNCTION (this);
+  return m_tcb -> GetPacingRate();
+}    
+
+// Set pacing rate (in tcp socket state).
+void TcpSocketBase::SetPacingRate (double pacing_rate) {
+  NS_LOG_FUNCTION (this << pacing_rate);
+
+  m_tcb -> SetPacingRate(pacing_rate);
+}
+ 
+// ADDITIONS FOR PACING: END
+///////////////////////////////////////////////////////////////////
+
 } // namespace ns3
diff -rupN ns-allinone-3.27/ns-3.27/src/internet/model/tcp-socket-base.h ns-allinone-3.27-bbr/ns-3.27/src/internet/model/tcp-socket-base.h
--- ns-allinone-3.27/ns-3.27/src/internet/model/tcp-socket-base.h	2017-10-11 16:39:00.000000000 -0400
+++ ns-allinone-3.27-bbr/ns-3.27/src/internet/model/tcp-socket-base.h	2018-01-30 18:14:05.421258572 -0500
@@ -21,6 +21,18 @@
 #ifndef TCP_SOCKET_BASE_H
 #define TCP_SOCKET_BASE_H
 
+///////////////////////////////////////////////////////////////////
+// Configuration options (to support BBR' and any paced protocols):
+// TCP_PACING - Packet pacing is done in TCP (in socket-base.cc).
+// APP_PACING - Packet pacing is NOT done in TCP, only in the application.
+// NO_PACING - No packet pacing is done (BBR' adjusts accordingly).
+enum enum_pacing_config {TCP_PACING, APP_PACING, NO_PACING};
+
+// Actual configuration option.
+const enum_pacing_config PACING_CONFIG = NO_PACING;
+
+///////////////////////////////////////////////////////////////////
+
 #include <stdint.h>
 #include <queue>
 #include "ns3/callback.h"
@@ -186,8 +198,23 @@ public:
   {
     return m_ssThresh / m_segmentSize;
   }
+
+  //////////////////////////////
+  // Additions for pacing.
+  void SetPacingRate (double pacing_rate);
+  double GetPacingRate () const;
+protected:
+  double            m_pacing_rate;                 // Pacing rate (in Mb/s).
+  //////////////////////////////
 };
 
+// Structure for tracking packets to send for pacing in TCP.
+struct tcp_pacing_struct {
+  SequenceNumber32 seq;    // Seq location in TCP buffer.
+  uint32_t maxSize;        // Bytes to extract.
+  bool withAck;            // Include ack or not.
+};
+  
 /**
  * \ingroup socket
  * \ingroup tcp
@@ -654,6 +681,7 @@ protected:
    * \returns the number of bytes sent
    */
   uint32_t SendDataPacket (SequenceNumber32 seq, uint32_t maxSize, bool withAck);
+  uint32_t SendDataPacketReal (SequenceNumber32 seq, uint32_t maxSize, bool withAck);
 
   /**
    * \brief Send a empty packet that carries a flag, e.g., ACK
@@ -812,6 +840,7 @@ protected:
    */
   virtual uint32_t UnAckDataCount (void) const;
 
+public: // Change status for BBR' support.
   /**
    * \brief Return total bytes in flight
    *
@@ -821,6 +850,7 @@ protected:
    */
   virtual uint32_t BytesInFlight (void) const;
 
+protected:
   /**
    * \brief Return the max possible number of unacked bytes
    * \returns the max possible number of unacked bytes
@@ -1071,6 +1101,20 @@ protected:
    */
   static uint32_t SafeSubtraction (uint32_t a, uint32_t b);
 
+  //////////////////////////////
+  // Additions for pacing.
+public:  
+  void SetPacingRate (double pacing_rate);
+  double GetPacingRate () const;
+
+  // Additions for pacing in TCP.
+protected:
+  EventId           m_pacing_event;                // Pacing event.
+  std::queue<tcp_pacing_struct> m_pacing_packets;  // Pacing packets.
+private:
+  void PacePackets();
+  //////////////////////////////
+  
 protected:
   // Counters and events
   EventId           m_retxEvent;       //!< Retransmission event
diff -rupN ns-allinone-3.27/ns-3.27/src/internet/wscript ns-allinone-3.27-bbr/ns-3.27/src/internet/wscript
--- ns-allinone-3.27/ns-3.27/src/internet/wscript	2017-10-11 16:39:00.000000000 -0400
+++ ns-allinone-3.27-bbr/ns-3.27/src/internet/wscript	2018-01-30 18:19:44.062260319 -0500
@@ -149,6 +149,8 @@ def build(bld):
         'model/tcp-hybla.cc',
         'model/tcp-vegas.cc',
         'model/tcp-congestion-ops.cc',
+        'model/tcp-bbr.cc',
+        'model/tcp-bbr-state.cc',
         'model/tcp-westwood.cc',
         'model/tcp-scalable.cc', 
         'model/tcp-veno.cc',
@@ -375,6 +377,8 @@ def build(bld):
         'model/tcp-hybla.h',
         'model/tcp-vegas.h',
         'model/tcp-congestion-ops.h',
+        'model/tcp-bbr.h',
+        'model/tcp-bbr-state.h',
         'model/tcp-westwood.h',
         'model/tcp-scalable.h',
         'model/tcp-veno.h',
